import { supabase } from '@/integrations/supabase/client';
import { v4 as uuidv4 } from 'uuid';
import { Meeting, CreateMeetingData, JoinMeetingData, MeetingSettings } from '@/types/meetingTypes';

// REMINDER: Regenerate Supabase types if you haven't already.
// `npx supabase gen types typescript --project-id YOUR_PROJECT_ID --schema public > src/types/supabase.ts`

// Helper function to map Supabase row to our Meeting type
// This avoids repetition and handles potential nulls for optional fields.
const mapSupabaseRowToMeeting = (dbRow: any): Meeting => {
  if (!dbRow) {
    // This case should ideally be handled before calling this mapper,
    // but as a safeguard:
    throw new Error("Database row is null or undefined, cannot map to Meeting.");
  }
  return {
    id: dbRow.id,
    title: dbRow.title,
    description: dbRow.description ?? null,
    hostId: dbRow.host_id,
    scheduledStartTime: dbRow.scheduled_start_time ?? null,
    scheduledEndTime: dbRow.scheduled_end_time ?? null,
    status: dbRow.status as Meeting['status'],
    settings: (dbRow.settings ?? {}) as MeetingSettings,
    participants: Array.isArray(dbRow.participants) ? dbRow.participants : [],
    createdAt: dbRow.created_at,
    updatedAt: dbRow.updated_at,
  };
};

export const meetingService = {
  async createMeeting(userId: string, meetingCreationData: CreateMeetingData): Promise<Meeting> {
    const newMeetingObjectForDb = {
      title: meetingCreationData.title,
      description: meetingCreationData.description,
      host_id: userId,
      scheduled_start_time: meetingCreationData.scheduledStartTime,
      scheduled_end_time: meetingCreationData.scheduledEndTime,
      status: meetingCreationData.status || 'scheduled',
      settings: meetingCreationData.settings || {},
      // id will be auto-generated by Supabase if not provided and column has default
    };

    const { data: insertedMeetingData, error: insertError } = await supabase
      .from('meetings')
      .insert(newMeetingObjectForDb)
      .select()
      .single();

    if (insertError) {
      console.error('Error creating meeting in Supabase:', insertError);
      throw new Error(`Failed to create meeting: ${insertError.message}`);
    }
    if (!insertedMeetingData) {
        throw new Error('Failed to create meeting or retrieve created data.');
    }
    return mapSupabaseRowToMeeting(insertedMeetingData);
  },

  async getMeetingById(meetingId: string): Promise<Meeting | null> {
    const { data: meetingData, error } = await supabase
      .from('meetings')
      .select('*')
      .eq('id', meetingId)
      .single();

    if (error) {
      console.error(`Error fetching meeting ${meetingId}:`, error);
      if (error.code === 'PGRST116') return null; // Not found
      throw new Error(`Failed to fetch meeting: ${error.message}`);
    }
    return meetingData ? mapSupabaseRowToMeeting(meetingData) : null;
  },
  async joinMeeting(joinData: JoinMeetingData): Promise<Meeting> {
    const { meetingId, userId, displayName } = joinData;

    const { data: currentMeetingData, error: fetchError } = await supabase
      .from('meetings')
      .select('participants, status, host_id, title, description, scheduled_start_time, scheduled_end_time, settings, created_at, updated_at, id') // Select all fields needed for mapSupabaseRowToMeeting
      .eq('id', meetingId)
      .single();

    if (fetchError || !currentMeetingData) {
      console.error(`Error fetching meeting ${meetingId} for join:`, fetchError);
      throw new Error(fetchError?.message || `Meeting with ID ${meetingId} not found.`);
    }

    const currentParticipants = Array.isArray(currentMeetingData.participants) ? currentMeetingData.participants : [];
    let updatedParticipants = [...currentParticipants];
    if (!currentParticipants.includes(userId)) {
      updatedParticipants.push(userId);
    }

    const { data: updatedMeetingData, error: updateError } = await supabase
      .from('meetings')
      .update({ participants: updatedParticipants })
      .eq('id', meetingId)
      .select()
      .single();

    if (updateError || !updatedMeetingData) {
      console.error(`Error updating meeting ${meetingId} for join:`, updateError);
      throw new Error(updateError?.message || 'Failed to update meeting for join.');
    }
    console.log(`User ${displayName} (ID: ${userId}) joined meeting ${meetingId}.`);
    return mapSupabaseRowToMeeting(updatedMeetingData);
  },
  async getUserMeetings(userId: string): Promise<Meeting[]> {
    // Fetches meetings where the user is the host or a participant.
    // This might require more complex query if participants are just an array of IDs.
    // For simplicity, let's assume we fetch meetings hosted by the user for now,
    // or you might have a separate participants table.
    // If 'participants' column is an array of user IDs:
    const { data: hostedMeetingsData, error: hostedError } = await supabase
        .from('meetings')
        .select('*')
        .eq('host_id', userId);
        // .or(`participants.cs.{${userId}}`); // If participants is an array containing the userId
                                          // .cs. means "contains" for array type

    if (hostedError) {
        console.error(`Error fetching meetings for user ${userId}:`, hostedError);
        throw new Error(`Failed to fetch user meetings: ${hostedError.message}`);
    }

    // Example if also fetching meetings where user is a participant (and participants is an array of IDs)
    const { data: participantMeetingsData, error: participantError } = await supabase
        .from('meetings')
        .select('*')
        .contains('participants', [userId]); // Check if userId is in the participants array

    if (participantError) {
        console.error(`Error fetching participant meetings for user ${userId}:`, participantError);
        // Decide how to handle this error, maybe log and continue with hosted meetings
    }
    
    const allMeetingsData = hostedMeetingsData || [];
    const participantMeetings = participantMeetingsData || [];

    // Combine and remove duplicates if any
    const combined = [...allMeetingsData, ...participantMeetings];
    const uniqueMeetings = Array.from(new Map(combined.map(m => [m.id, m])).values());

    return uniqueMeetings.map(mapSupabaseRowToMeeting);
  },

  generateMeetingLink(meetingId: string): string {
    // Ensure NEXT_PUBLIC_APP_URL is set in your environment variables
    const appBaseUrl = process.env.NEXT_PUBLIC_APP_URL || window.location.origin;
    return `${appBaseUrl}/meet/${meetingId}`; // Example link structure
  },

  async deleteMeeting(meetingId: string, userId: string): Promise<void> {
    // Add a check to ensure only the host can delete the meeting, or based on your app's logic
    const { error: deleteError } = await supabase
      .from('meetings')
      .delete()
      .eq('id', meetingId)
      .eq('host_id', userId); // Ensure only the host can delete

    if (deleteError) {
      console.error(`Error deleting meeting ${meetingId}:`, deleteError);
      throw new Error(`Failed to delete meeting: ${deleteError.message}`);
    }
    console.log(`Meeting ${meetingId} deleted by user ${userId}.`);
  },
};
export type {
    CreateMeetingData // but as a safeguard:
    , Meeting
};

